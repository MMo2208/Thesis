\documentclass[12pt,a4paper]{article}

\usepackage{graphicx}
 \usepackage{subfigure} 
 \usepackage[english]{babel}
 \usepackage[format=default,font=footnotesize,labelfont=bf]{caption}
\usepackage[ansinew]{inputenc} 		%Umlaute
\usepackage[T1]{fontenc} 				%Umlaute		
\usepackage[margin=1in]{geometry}		%Randabstand
\usepackage[onehalfspacing]{setspace}	%Zeilenabstand 1,5

\usepackage{floatflt}					%Umflossene Grafiken
\usepackage{float}
\usepackage[section]{placeins}
\usepackage{afterpage}
\usepackage{tabularx}

				%Highlight-boxen

\usepackage[framemethod=tikz]{mdframed}
\usepackage{lipsum}
\usepackage[many]{tcolorbox}

\newtcolorbox{myboxii}[1][]{
  breakable,
  freelance,
  title=#1,
  colback=white,
  colbacktitle=white,
  coltitle=black,
  fonttitle=\bfseries,
  bottomrule=0pt,
  boxrule=0pt,
  colframe=white,
  overlay unbroken and first={
  \draw[red!75!black,line width=3pt]
    ([xshift=5pt]frame.north west) -- 
    (frame.north west) -- 
    (frame.south west);
  \draw[red!75!black,line width=3pt]
    ([xshift=-5pt]frame.north east) -- 
    (frame.north east) -- 
    (frame.south east);
  },
  overlay unbroken app={
  \draw[red!75!black,line width=3pt,line cap=rect]
    (frame.south west) -- 
    ([xshift=5pt]frame.south west);
  \draw[red!75!black,line width=3pt,line cap=rect]
    (frame.south east) -- 
    ([xshift=-5pt]frame.south east);
  },
  overlay middle and last={
  \draw[red!75!black,line width=3pt]
    (frame.north west) -- 
    (frame.south west);
  \draw[red!75!black,line width=3pt]
    (frame.north east) -- 
    (frame.south east);
  },
  overlay last app={
  \draw[red!75!black,line width=3pt,line cap=rect]
    (frame.south west) --
    ([xshift=5pt]frame.south west);
  \draw[red!75!black,line width=3pt,line cap=rect]
    (frame.south east) --
    ([xshift=-5pt]frame.south east);
  },
}

\usepackage{fancyhdr}
\pagestyle{fancy}

\usepackage{listings}				%Codelisting
\usepackage{courier}
\usepackage{color}
\usepackage{acronym}				%Abkürzungen
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.98,0.98,0.98}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{blue},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=false,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}


\fancyfoot{}
\fancyfoot[R]{\thepage}

\usepackage{hyperref}
\usepackage{multibib} 
\newcites{Refs,Urls}{Literaturverzeichnis,Verzeichnis der Webadressen}

\usepackage{url}

\begin{document}

%==================Deckblatt===========================%
\ \vspace{0.1cm} 
\begin{center} 

\begin{huge} 
Bachelorthesis \\ 
\end{huge}
\ \\
\vspace{1cm} 

\noindent\rule{16cm}{-2em} 
\hrule\par\rule[-1em]{0pt}{2.5em}
\begin{large}
\textbf{Development of a Web-Application\\
for executing Job-Scripts on an IBM-Mainframe\\
in context of Education\\}
\vspace{0.3cm}
\end{large}
\hrule\par\rule{0pt}{2em}
\ \\
\vspace{1cm} 


\begin{small}
Bachelorarbeit gemäß § 17 der Allgemeinen Prüfungsordnung vom 01.08.2008 \\
im Bachelorstudiengang Informationsmanagement und Unternehmenskommunikation \\
an der Hochschule für angewandte Wissenschaften Neu-Ulm \\
\end {small}

\vspace{3cm} 


\end {center}

\begin{table} [!h]
\begin{tabular}{lll}

	Erstkorrektor	& 	&	Prof. Dr. Phillipp Brune \\
	Betreuer 		& 	&	Dr. Kevin Henrichs \\
	 & & \\
	Verfasser		&	&	Marc Morschhauser (Matr.-Nr.: 204041)\\
	 & & \\
	  & & \\
	   & & \\
	Thema erhalten & & 01.01.2020 \\
	Arbeit abgegeben & & 01.05.2020 \\

\end{tabular}
\label{tab:threecols}
\end{table}


\vspace{3cm} 
\noindent\rule{7.5cm}{1pt}\hspace{1cm}\noindent\rule{7.5cm}{1pt}
\hspace*{1cm}Unterschrift des Studierenden\hspace{2.7cm}Unterschrift und Firmenstempel der \\
\hspace*{10.5cm}Ausbildungsstelle
\thispagestyle{empty}
\newpage
%==================Ende Deckblatt===========================%
\begin{center}
In association with:
\vspace{1.5cm}
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.25]{img/Logos.jpg}
\end{figure}

\end{center}
\thispagestyle{empty}
\newpage
%==================Ende Logos===========================%

\pagenumbering{Roman}

\section{Abstract}
Hier kommt der/die/das Abstract.\\

\newpage

\listoffigures

\newpage
\section{List of abbreviations}
\begin{acronym}[Bash]
	 \acro{IoT}{Internet of Things}
	 \acro{I/O}{Input / Output}
 	 \acro{OS}{Operating System}
	 \acro{ULE}{Ubiquitous Learning Environment}
	 \acro{JCL}{Job Control Language}
 	 \acro{JES}{Job Entry Subsystem}
  	 \acro{TSO}{Time Sharing Option}
 	 \acro{USS}{Unix System Services}
 	 \acro{OLTP}{Online Transaction Processing}
	 \acro{LPAR}{Logical Partitions}
	\acro{LAN}{Local Area Network}
	\acro{FTP}{File Transfer Protocol}
	\acro{SSH}{Secure Shell}
	\acro{SFTP}{Secure File Transfer Protocol}
	\acro{VPN}{Virtual Private Network}
	\acro{MVS}{Multiple Virtual Storage}
\end{acronym}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}




%===========Main Content=========%
\setcounter{page}{3}
%\begin{onehalfspacing}

\newpage

\section{Introduction}
Big Data, Cloud, Blockchain, \ac{IoT}  - Digitalization is steadily proceeding and with it the amount of data that has to be processed every day. Many web-services at this point are dependent on flexibility in first place. Big server farms facilitate an unprecedented agility to operators of online-businesses referring to their resource-planning. Urgent situations with high data traffic can be handled by adding physical or also virtual servers within minutes. However there are services where minutes make the difference between millions of euros. Those services demand for information technology, which not only has a high data throughput but also ensures the highest availability. The IBM Mainframe in its newest construction provides an \ac{I/O} of 288GB per second  while being available 99,999\% of the time running. This makes the Mainframe a cornerstone in present finance-sector's IT-management. Due to it's security and it's high speed it also finds it's use in other big industries - thus also insurances, the aerospace industry or big retail companies benefit from this supercomputer.\\
But since the IT improved considerably over the last decades, the Mainframe was presumed dead and many companies discontinued training their staff to maintain this technology. Contrary to their expectations they are dependent on it till today and they will presumably be in the remote future. What is left is a big gap in the division of skilled professionals that is hard to close.\\
The Goethe-University in Frankfurt, Germany, attends to participate in closing this gap. Therefore the university procured one of the aforementioned IBM supercomputers to train their students dealing with it.\\
\ \\
This Bachelor Thesis approaches a Front-End-Application, which will be running on a Linux Virtual-Machine but executing tasks on the mainframe's \ac{OS} called z/OS. By building this bridge between the Linux VM and the z/OS, students will be able to get in touch with the Mainframe located in Frankfurt University through a web-browser and as a consequence experience how the system is working.\\
\ \\
The resources for this activity are allocated by the \textit{Talentschmiede AG} - a Frankfurt located IT consultancy which is in close contact to the finance sector and knows and cares about the gap of skilled professionals. Further it is supported by the \textit{Academic Mainframe Consortium e.V.} - an association founded by Mainframe Experts which are also willing to acquire new educated staff in the division of Mainframe.
\newpage

%================== Related Work ===========================%



\section{Related Work}
While a malicious tongue once suggested that " the last mainframe will be unplugged in 1996 " , it reconsidered when IBM introduced it's latest version of it in 2008 \cite{lohr2008old}. Till the present day the mainframe is the backbone of the financial markets worldwide and just as important for other big industries\cite{carayannisenterprise} \cite{lohr2006ibm}.
The view on the mainframe technology as an IT-dinosaur has to change and the need of adding the mainframe technology to the IS Curriculum in a wide range was overdue already 10 years before \cite{wallis2007s} \cite{wong2009old} \cite{douglas2009enterprise}. Sharma et al. analysed the need of Large System Education regarding to mainframe education and they are investigating " the   academic response   to   the   need   for   large   systems specialists " \cite{sharma2011teach}. In \cite{corridori2009ways} A. Corridori addresses the concerns and the opportunities that come with adding mainframe content to universities curricula and also previews ways to do this. How the economy and with it, the labor market can benefit from it is stated in \cite{sharmaalive}. \\
\ \\
The potentials of present digital media used to educate in a wide range is discovered by Cope et al. \cite{cope2009ubiquitous}. It is described that "the learner's  relationship  to knowledge  and  the  processes  of  pedagogy  have  not  changed  in  any  significant  way" but through technology " the educational paradigm has changed ". Vicki Jones et al. also address the integration of modern information technology in everyday's life and the advantages of this change regarding education \cite{jones2004ubiquitous}. Here it is stated that " Adaptive learning can offer great advantages in providing students with specific and personalised knowledge as and when required ". While the term " Adaptive Learning " is responsive to the methods that are used to transfer knowledge \cite{midgley2014goals} , " \ac{ULE} " describes an environment with the possibility of learning everywhere and anytime\cite{hwang2008criteria}. Hwang et al. emphasize the fact, that ULEs are an innovative approach for teaching complex topics \cite{hwang2009context}. To establish a ULE there are many technologies needed \cite{sakamura2005ubiquitous}, this thesis is supposed to do a first step in this direction to learn on the Mainframe anywhere and anytime.\\

\ \\
Kiefer, COBOL as a modern language \cite{kiefer2017cobol}\\
Khadka, How do professionals perceive legacy systems and software modernization? \cite{khadka2014professionals}\\
Vinaja, 50th anniversary of the mainframe computer: a reflective analysis \cite{vinaja201450}\\

......

\newpage

%==================Overview on Mainframe / z/OS===========================%


\section{An overview on the IBM Mainframe}
Prior to entering the main issue of implementing the web-application, this chapter introduces a few mainframe terminologies to assure a full understanding of the steps that take place in the following chapters. \\
Because, while many people just take the easy way by calling almost every computer a \textit{server}, and the term \textit{mainframe} is often just used to point out that this is the largest server in use, in this thesis the term \textit{mainframe} describes the IBM Supercomputer which is capable of "supporting thousands of 
applications and input/output devices to simultaneously serve thousands of users" \cite{ebbers2016introduction}.\\
So the most common utilization of the mainframe is divided in two categories: 
\begin{itemize}
\item \ac{OLTP}, incl. web-based applications
\item Batch Processing
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/batchtrans.png}
	\caption{Typical workloads}
	\label{Typical workloads}
\end{figure}
\ \\
\subsection{Online Transaction Processing}
One of the core functions of many businesses is OLTP. For this case the mainframe serves a large amount of applications to make it possible to execute thousands of transactions in short time while handling not only a huge amount of different transaction types, but also to do this with many different users at a glance.\\
For end-users those transaction processes are often commonly known, while they appear in everyday's life, such as:
\begin{itemize}
\item Credit card payments in supermarkets
\item ATM transactions
\item Online purchasings
\end{itemize}

So in many cases you are already using a mainframe without even taking any note. Since these transaction processes are generally carried out through web-technology they are not to be consolidated in this thesis.

\subsection{Batch Processing}
The other main function of the mainframe is processing data in a batch. Eventually terabytes of. These processes are generally done without much user interaction. A batch job simply gets committed and processes the data that is determined in the job-statement.\\
\ \\
While we dive deeper into the Job-Creation-Language that leads to those processes in chapter \ref{JCL}, it is important for now to understand the concept of these jobs that can be imagined equivalent to a UNIX script file or a Windows command file. The difference is, that z/OS batch-job processes millions of records.\\
A famous and easy understandable example for a classical batch-job is the payroll of a big-company. z/OS here takes up a core function by bringing together a huge amount of data consisting of personal data, data referring to working hours and salaries. The mainframe is predestined to work this out on a safe and reliable basis.\\
\ \\
But of course there are also people included in this process that have to be reliable as well but in addition also have to govern this whole process what makes them exactly the target group of the application that will be developed in this thesis.\\

\ \\
\subsection{Separation of duties}
To define the target grouper in more detail, this chapter will give a quick overview on people that have contact to the mainframe in daily work life.\\
distinguish between:
\begin{itemize}
\item System programmers 
\item System administrators (for example, DBA, storage, network, security, and 
performance)
\item Application designers and programmers 
\item \textbf{System operators (explain)}
\item Production control analysts
\end{itemize}
\ \\
\subsection{Mainframe Operation Systems}
Another ambit where insights are required for further understanding of the application is the ambit of the different Operation Systems that can be run on the mainframe.\\

-- z = zero Downtime?! --\\
\ \\
\begin{itemize}
\item \textbf{z/OS} is the IBM operating system that runs on most z-system mainframe installations and by that takes the leading role in the field of mainframes. It isn't set apart a lot from normal operating systems as it has the same structure of three layers, consisting of Hardware, Operating System and User Processes. Similar to modern windows-systems there are some kind of subsystems, which run between the OS and the user processes. The most important one in the case of z/OS are the \ref{JES} for the background operations (batch processing), the \ref{TSO} for the foreground operations (interactive) and the \ref{USS}, which represent a posix-compatible unix subsystem.
\item \textbf{z/VSE}
\item \textbf{z/TPF}
\item \textbf{z/VM}
\item \textbf{Linux for zSeries}
\end{itemize}
\ \\


\subsection{Virtualisation with z/VM}
\textit{As an aid to consolidation, the mainframe offers software virtualization, through z/VM. z/VM?s extreme virtualization capabilities, which have been perfected since its introduction in 1967, make it possible to virtualize thousands of  distributed servers on a single server, resulting in the significant reduction in the use of space and energy. }
\ \\
\textit{z/Virtual Machine (z/VM) has two basic components: a control program (CP) and 
a single-user operating system (CMS). As a control program, z/VM is a hypervisor because it runs other operating systems in the virtual machines it creates. Any of the IBM mainframe operating systems such as z/OS, Linux on System z, z/VSE, and z/TPF can be run as guest systemsin their own virtual machines, and z/VM can run any combination of guest systems.}\\
\textbf{---- Explain and show z/VM Constellation, LPARs etc ---- }
\ \\
more in : \url{http://www.redbooks.ibm.com/redbooks/pdfs/sg247603.pdf}
\newpage


%================== Research Gap ===========================%


\section{Research gap}
While the web-access to z/OS for OLTP is very established because of the usage, that is often conducted by end-users or computers, that are not located in immediate proximity to the server, the access to the JES-spool through web-applications is less common, since the system-operators are usually working in ultimate contact to the mainframe.\\
Certainly there are operators handling batch-processes through a web front-end due to flexibility and simplicity reasons. But while these applications are to simplify the process of managing the workload in daily-business, this thesis tries to establish an environment where the jobs have to be done in full amplitude, but on a test-system, implemented just for educational reasons.\\
This setup will have the ambitions of getting people into JCL quite quickly on the one hand and give them the opportunity to train their abilities and, in this way reduce potential uncertainties towards working on large-scale systems, on the other hand. With this method a pertinent and long-lasting learning effect is to be achieved in short time.\\
\newpage


%================== JCL ===========================%


\section{Dive into \ac{JCL}}
\label{JCL}
\textbf{---- Important to understand JCL for accessing JES Spool?! ---- }\\
\ \\
To get familiar with JCL, this chapter will give an introduction in how these Statements are working. There is talk about "Statements", because JCL is used to tell the OS what to do. Each Statement is an independent work unit, known as "Job" - therefore this language is called "Job Control Language". Each Job consists of instructions that are either typed in by an operator or they are stored and get transmitted to the computer. \\ 

\subsection{Job Control Environment}
So to understand how a job is executed, it is important to know which components are needed for this process.\\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.25]{img/JCL-1.jpg}
	\caption{JCL Functionality, Source: IBM}
	\label{JCL Functionality}
\end{figure}
\ \\
On figure \ref{JCL Functionality} you can see a job process described in 7 steps.\\
\begin{enumerate}
\item JCL submit 
\item JCL requests program 
\item Program gets loaded
\item Resources for program get allocated through JCL
\item Resources get provided to program
\item Program writes output to JES Spool
\item Output to gets transferred to printer as requested
\end{enumerate}
\ \\
The z/OS has written (hard coded) application programs which are not associated with any physical resources. Those programs are just names, which include internal file-names. Through JCL those programs can be opened for reading and writing during execution.\\
The \ac{JES} is there to evaluate and accept or not accept a job. If the syntax is right and the job is accepted the JES runs it on the OS and controls this process. The results get transferred to an output unit.\\


\subsection{Job structure}
-each statement 80characters\\
-JCL is introduced with // \\

\subsubsection{EXEC-Statements}
Within a job, there are working executions introduced through an "EXEC-statement". Every job needs at least one execution, but there can obviously be many more in addition. If a job has no execution it stops.
\ \\
\begin{lstlisting}[language=PHP]
//STEP0001 EXEC PGM=IEBGENER
...
//STEP0002 EXEC PROC=PRDPROC1
//STEP0003 EXEC PRDPROC2
\end{lstlisting}


\subsubsection{DD-Statements}
\begin{itemize}
\item{SYSUT1}
\item{SYSUT2}
\item{SYSIN}
\item{SYSPRINT}
\end{itemize}
-JCL links the program file names with physical resources (e.g. data set names or unix file names).\\
--JCL is used to process programs in the background ("batch")\\
- And to process programs in the foreground("started task")\\
-JCL instruct z/OS -> Start / submit
- JCL SUBMIT Statement will result in batch process of one or more programs (BACKGROUND)\\
- JCL START will result in FOREGROUND processing of a processing program\\
\ \\
\subsubsection{Background / Foreground jobs}
Every Batch Job must contain JOB-statement \& EXEC statement\\
->JOB statement highlight the beginning of a batch job \& assigns a name to the job\\
JCL started tasks do not require a JOB Statement
->both have at least one EXEC statement -> marks the beginning of a job step , assigns name to the step \& identifies the program or procedure to be executed in the step.

\newpage



%================== Get Access to JES ===========================%



\section{Access possibilities}
In order to execute JCL-Jobs on z/OS from the Linux host, an access point is required to submit the data. This chapter is to reveal how the z/VM connects the Linux-host and the z-OS Target-system in this case and how this connection can be used to transfer data among them.\\
To enable the communication between different applications, a protocol is needed. The protocol that is used in the System Z is the \ac{TCP}/\ac{IP}, which is provided through the HiperSockets function. HiperSockets is a technology developed by IBM to enable high-speed communication between \ac{LPAR} with a hypervisor or between applications inside a z/VM as it is the case here.\\
You could imagine a HiperSockets-network like an internal \ac{LAN}, linking all partitions for internal communication.\\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{img/Hiper.png}
	\caption{TCP/IP Connection / Hipersockets}
	\label{Hipersockets}
\end{figure}
\ \\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.7]{img/workloads.png}
	\caption{workloads}
	\label{workloads}
\end{figure}

\textbf{---- Explain Hipersockets / TCP/IP Connection ---- }\\
A way we can use this connection to transfer jcl-jobs is:
\ \\
\begin{myboxii}[Transmission Control Protocol]
The Transmission Control Protocol (TCP) provides a reliable vehicle for delivering
packets between hosts on an internet. TCP takes a stream of data, breaks it into
datagrams, sends each one individually using IP, and reassembles the datagrams at
the destination node. If any datagrams are lost or damaged during transmission,
TCP detects this and resends the missing datagrams. The received data stream is a
reliable copy of the transmitted data stream.

\textbf{---- Explain TCP/IP Connection in own words ---- }\\

\end{myboxii}
\ \\
\subsection{Access through Java with FTP}
What becomes possible through the TCP/IP in System Z is the \ac{FTP} Server, an IP-application used to transfer files between any kind of platform. The z/OS FTP-Server is a bit different from normal FTP-Servers as it provides not only the possibility to transfer files and get access to z/OS System Services, but it also provides access to the Job Entry Subsystem which is, as mentioned in  chapter \ref{JCL}, needed to submit JCL-Jobs.\\

With the help of Java you can use the FTP server to get access to a number of JES functions, including the following:
\begin{itemize}
\item Submitting a job
\item Displaying the status of jobs
\item Receiving the spool output of a job (JCL messages and SYSOUT)
\item Deleting a job
\item Submitting a job and automatically receiving output
\end{itemize}
\ \\
\textbf{---- Importance of output for Learning environment ---- }\\

\subsection{Access via \ac{SSH}/ \ac{SFTP}}
While FTP gives us the opportunity to get access to the JES-Spool to run JCL-Jobs, this is not really a safe way to work this out.\\
To get a safe communication, it needs encryption what can be established through the SSH-protocol - making the FTP a Secure File Transfer Protocol.\\

\begin{myboxii}[The Secure Shell Protocol]
The SSH protocol (also referred to as Secure Shell) is a method for secure remote login from one computer to another. It provides several alternative options for strong authentication, and it protects the communications security and integrity with strong encryption. It is a secure alternative to the non-protected login protocols (such as telnet, rlogin) and insecure file transfer methods (such as FTP). 
\textbf{---- Explain SSH in own words ---- }\\

\end{myboxii}

\subsection{Co:Z SFTP-Server}

\textbf{---- Describe Co:Z ---- }\\
A tool named Co:Z SFTP, an open-source product developed by Dovetailed Technologies, will help to establish a safe connection with before mentioned techniques. It works as a port of OpenSSH SFTP for z/OS and therefore enables the access to z/OS datasets and spool files.\\

\newpage

%================== Requirements and Development ===========================%


\section{Requirements}
To get access to z/OS, a system constellation as seen on Fig. \ref{constellation} will be implemented. A z/VM running Linux (LPAR 1) will serve as a web-server. Here the application is hosted and can be accessed through the user's web-browser. Due to the hipersockets network, that links LPAR 1 to the z/OS (LPAR 2), whereupon an SFTP-Server can be running, a stable and safe connection can be established. As before mentioned, the Co:Z SFTP-Server is deployed here, to get direct access to the JES-Spool. Through this constellation, students will be able to submit jobs directly on the mainframe, from any given device that they are using to access the internet.\\

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{img/Schemahosting.jpg}
	\caption{constellation}
	\label{constellation}
\end{figure}

\url{http://www.redbooks.ibm.com/redbooks/pdfs/sg247603.pdf}
from p.137
\newpage

\textbf{---- Ubuntu / Apache Server etc.?! Implementation part ---- }\\
\textbf{---- Node.js website / hosting / Electron ---- }\\


\newpage

%================== Design ===========================%


\section{Design}
In this chapter, a framework, based on the node-stack, is used to implement the web-application. This framework, called Express, gives the opportunity to develop the javascript-application within an MVC-pattern, that can run on our zLinux and can be accessed through the browser. For local development, the mainframe access takes place through a \ac{VPN} that is provided by the Frankfurt University. Later this application will be installed on zLinux, so the backend can access z/OS directly through the hipersockets network.\\
Since the Co:Z-SFTP-Server in its handling, differs slightly from usual SFTP-Servers, becoming noticeable through the commands that have to be executed, the following subchapters provide a brief glimpse on how the actions would be executed through a terminal. But it is avoided to go too much into detail here, as the focus is on the realisation through javascript, as these are the functions, which are triggered in the application in the end.\\ \\
For further interests, the full Co:Z documentation can be read on \hyperlink{http://dovetail.com/docs/sftp/using.html}{http://dovetail.com/}.\\
\\
The following chapter will describe the whole application on the basis of the MVC-pattern on Fig. \ref{Model-View-Controller Scheme}. A quick overview should help to get to know the functionalities straightforward. How the functions are implemented exactly will be described in the following subchapters. The operations that are listed on Fig. \ref{Model-View-Controller Scheme} all take place after the user is logged in. \\
\ \\
From Left to Right the first entry point is the HTTP Request to the \textit{routes.js}-file. This happens, when the user is logged in and gets redirected to the home view, which loads the \textit{home.jade}-file. \textit{Jade} is a template engine, used for serverside rendering of HTML-files in NodeJS. In this case home.jade renders a file called \textit{index.html}. This is the front-end, that the user will see and will interact with.( Fig. \ref{welcomeview}, \ref{listview}, \ref{textarea}, \ref{successview} )\\
The two other routes that are called here pass the userdata for accessing the mainframe to functions in the \textit{sftpManager.js} which works as model and is running as backend on the server. This model is the heart of this application as it contains all the logic to exchange data not only between the user and the database but also between the user and the mainframes' z/OS via SFTP.\\
The \textit{myController.js} works as a middleware between front- and backend and therefore is used to manage responses from the mainframe and update the user on this operations. \\ \\
After the functionality of the applications is clear, chapter \ref{learning-content} will introduce a few thoughts on how the users can learn from this program and how those thoughts are transposed.\\

\newpage
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/MVC-Express.jpg}
	\caption{Model-View-Controller Scheme}
	\label{Model-View-Controller Scheme}
\end{figure}

\subsection{Registration / Login}\label{Login}
To be able to work on the IBM Machine, the students have to be added as authenticated users on the mainframe first. This has to be done by a mainframe administrator before. With given user-data they are ready to register for and use the Mainframe-Self-Service.\\
An open-source login template, implemented by Stephen Braitsch ( \hyperlink{https://github.com/braitsch/node-login}{https://github.com/braitsch/node-login} ) will help to get started with the user registration and log-in. This template is built on the MongoDB database, which is a simple non-relational database also known as NoSQL-database. By registration this template saves the username and the password along with some other userdata into this database. There should not be too much detail about the login template here, as it is not part of the thesis. The documentation on its function can be read on the before mentioned github project of Stephen Braitsch.\\ \\
The favor of this node-login is that when the user logs in its userdata is not only accessible from the database but also from an array called \textit{session}. This session just exists as long as the user is logged in and gets destroyed when he logs out. From this session we take our userdata to access the mainframe. \\
\ \\
For the next sections, an SFTP-Client is implemented to get a connection to Co:Z-SFTP. The node package \textit{ssh2.js} by Brian White makes it possible to use the openSSH protocol as it is also used by Co:Z-SFTP.
To access z/OS via SFTP we use the ssh2-package by requiring it on line 1. Then we establish a variable \textit{connSettings} which contains all the requirements to access the mainframes' z/OS through SFTP and get access to the JES-Spool to read and write data. The host called here is the IP-Address of the Co:Z Server, port 22 is the port that is usually used for guest-access via SFTP. The guest-access is required due to the web-server running not in the same LPAR as the z/OS. In line 5 and 6 in the following code you can see that a request (req) is made to the session array to read the username and the password stored here as long as the user is logged in. How this data is passed to the functions can be seen in the chapters \ref{yourjobs} and \ref{submitjob}. \\
\begin{lstlisting}[language=Java]
var Client = require('ssh2').Client;
var connSettings = {
     host: '141.2.192.32', 							// Mainframes z/OS
     port: 22, 													// Guest-SFTP Port
     username: req.session.user.user, 	// Request sessions' username
     password: req.session.user.pass 		// Request sessions' password
};
\end{lstlisting}
\ \\
\subsection{Welcome}
When a user is logged in it gets provided a one-page-layout program, which is devided into four sections. These sections and their functions are explained in the following.\\ 
As before mentioned the entry point is the \textit{routes.js}-file. Here the home.jade file is called after login to render the index.html. This is done by the following code.\\
\ \\
\textit{For a better understanding, the Filename is always listed before the code. As long as it doesn't change throughout the code-listings, it is the same file as before.}
\\
\begin{lstlisting}[language=Java]
// routes.js

	app.get('/home', function(req, res) {
		if (req.session.user == null){
	// if user is not logged-in redirect back to login page //
			res.redirect('/');
		}	else{
			res.render('home', {
				title : 'Control Panel',
				countries : CT,
				udata : req.session.user
			});
			}
	});
\end{lstlisting}
\ \\
On line 11 you can see that the sessions' userdata is already requested when the program is loaded. If there is something wrong the user gets redirected to the login-page.\\
The first section simply welcomes the user to the self service. 
This is the view, the user sees, when entering the program.\\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.35]{img/view_welcome.png}
	\caption{Welcome View}
	\label{welcomeview}
\end{figure}

\subsection{Your Jobs}\label{yourjobs}
In this section the user should get an overview on the jobs listed in his JES-Spool. Therefore the index.html contains a simple empty div-container that gets filled with a Table of job-files if he submitted jobs so far.
\ \\
\begin{lstlisting}[language=HTML]
// index.html

       <!-- Here the JES-Spool is listed -->
       <div id="dirout" style="max-height:800px;overflow:auto;">
       </div>
\end{lstlisting}
\ \\
To create this table with the wanted content it takes a few steps. In \textit{home.js}, a file that is part of the node-login and therefore is not listed on the figure above, we do a jQuery GET request, when the document is loaded.
\ \\
\begin{lstlisting}[language=Java]
// home.js

$(document).ready(function(){

//Get Job list
	$.get("/data-list", function(list) {
	// give the content 'list' in form of html to a div with the ID 'dirout'
		$("#dirout").html(list);
	});
\end{lstlisting}
\ \\
This requests data from the \textit{/data-list} route. Here it requests a variable \textit{list} which it wants to give to the \#dirout-div in form of html.\\
The route that is requested looks like this:\\

\begin{lstlisting}[language=Java]
// routes.js

// Establish the sftpManager as variable to use it in route
var SF = require('./modules/sftpManager');

// Route for getting job-list
	app.get('/data-list', function(req, res) {
	// pass user-data to function getList()
			SF.getList(req, res, connSettings = {
				host: '141.2.192.32',
				port: 22, 
				username: req.session.user.user,
				password: req.session.user.pass,
			});

	});
\end{lstlisting}
\ \\
Here the \textit{sftpManager.js} is defined as a variable to use it in the route (line 1). The route itself uses this variable to get the sftpManager to trigger the function getList() along with the user-data located in \textit{connSettings}.\\ \\
The Jobs that were submitted, are located in a directory on z/OS called "//-JES" from here they can be passed to the container in the form of a table.\\
The command that is usually used to read data in this directory on the Co:Z SFTP-Server is:
\begin{lstlisting}[language=HTML]
sftp>  ls -al //-JES
\end{lstlisting}
This command leads to a list of all spool-files and some information to them in form of a table in a shell or terminal. To trigger this kind of listing, the ssh2-library provides the command \textit{readdir} to list the requested directory.\\
With the following function in the sftpManager, the jobs are passed to the application.\\
\begin{lstlisting}[language=Java]
//sftpManager.js

  getList(req, res) {
    var remotePathToList = '//-JES';		    //JES-Spool Listing

    var conn = new Client();				// Establish SFTP Connection
    conn.on('ready', function() {
        conn.sftp(function(err, sftp) {
          if (err) {
            //send error to myController if something went wrong
            res.send(400);
          } else {
		
		// read the //-JES directory
             sftp.readdir(remotePathToList, function(err, list) {
                    if (err) throw err;

                    // Return list
                    var rows = list;
			
		//Creata a table and fill with job-list
                    var jobs = "<table id='jobtable' border='1|1'>";
                    for (var i = 0; i < rows.length; i++) {
                        jobs+="<tr>";
                        jobs+="<td>"+rows[i].filename+"</td>";
                        jobs+="<td>"+rows[i].longname+"</td>";

                        jobs+="</tr>";
                    }
                    jobs+="</table>";

		// send the job-table
                    res.send(jobs);

                  // We're just calling the list once, 
                  // so the connection has to be ended now
                    conn.end();
             });
           }
        });
    }).connect(connSettings);
  },
\end{lstlisting}
\ \\
Through this, the jQuery GET request mentioned at the beginning gets a variable \textit{list} that contains all spool-files in form of a html table. This table is given to the \#dirout-div and is shown in the browser.
\ \\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.35]{img/view_jobtable.png}
	\caption{List of JES-Spool files}
	\label{listview}
\end{figure}
\ \\
\ \\
\subsection{Submit a new Job}\label{submitjob}
As FTP is short for File-Transfer-Protocol, there first has to be a file to be transferred. Node for this situation provides a module called \textit{file-system}. With this module it is possible to create a .txt file through a textarea. \\

\begin{lstlisting}{language=HTML}
// index.html

        <div class="field">
          <textarea name="content" id="JCLcontent" 
          placeholder="Your JCL goes here." rows="10" cols="50"></textarea>
        </div>
        <div class="field" style="margin-top:30px;">
          <p id="filesuccess">Write your Job in the textarea above 
          and click on Submit Spool-File.</p>
          <button id="createSpool" onclick="createSpoolfile()">
          Submit Spool-File</button>
          <div id="messages"></div>
        </div>
\end{lstlisting}
\ \\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/view_textarea.png}
	\caption{Textarea for typing JCL-Jobs}
	\label{textarea}
\end{figure}
Here the JCL-code can be written. Beneath the textarea, there is a Button saying "Submit Spool-File" that has the onclick-event "createSpoolfile()", which triggers the following function.\\

\begin{lstlisting}[language=Java]
//myController.js

function createSpoolfile() {
  var filecontent = $("#JCLcontent").val();
  var filesuccess = document.getElementById("filesuccess");
  var resultinfo = document.getElementById("resultinfo");

  //Check if textarea contains content
  if (!filecontent) {

    filesuccess.style.color = "#ff9800";
    filesuccess.innerHTML = "Please write a Job first.";

  } else {

    filesuccess.style.color = "#00e676";
    filesuccess.innerHTML = "Your Job is on its way to the mainframe. 
    		Scroll down to see the result.";

  //Define value of textarea as json-object
  var json = {
    content: filecontent,
  };

  // if it does call create-file in routes
  $.ajax({
    type: 'POST',
    url: '/create-file',
    data: json,
    
    ... to be continued in chapter 10.5.

\end{lstlisting}
The function createSpoolfile() that is triggered through the button first checks if the textarea even contains content. If it does not, it advises the user to "write a job first". If the textarea has content, the function here defines this value as a json object and does an ajax-call. This ajax-call of the type POST sends the information as a json-object to the url: /create-file in routes.js. \\

\begin{lstlisting}[language=Java]
//routes.js

	// Route for creating and submitting file
	app.post('/create-file', function(req, res) {
		SF.createFile(req, res, connSettings = {
			host: '141.2.192.32',
			port: 22, // Guest-port is 22
			username: req.session.user.user,
			password: req.session.user.pass,
		});
	});
\end{lstlisting}
This route again triggers a function in the sftpManager.js and sends the data for the connection to the mainframe. The difference to the above route is that here we have a POST-routing which means we don't request data but we send data to the mainframe. This happens in the function createFile.

\begin{lstlisting}[language=Java]
//sftpManager.js

  createFile(req, res) {
    var filedir = './Spool-files/' + req.session.user.user;
    var filepath = './Spool-files/' + req.session.user.user + '/JCL.txt';
    var fileContent = req.body.content;

    if (fileContent != '') {

      var dir = './Spool-files/' + req.session.user.user;

      //Create User-folder for JCL files
      if (!fs.existsSync(dir)){
        fs.mkdirSync(dir);
      };

      // When folder exists, create textfile
      fs.writeFile(filepath, fileContent, (err) => {
        if (err) {
          throw err;
        } else {
          this.transFile(req, res, connSettings);
        }
      });
    }
  },
\end{lstlisting}
createFile() first checks if the user already has an own directory for his Spool-files to be submitted. If not it creates a subdirectory in the directory 'Spool-files' with the users name. Here it writes a .txt-file with the value of the textarea. After that it triggers the transFile()-function which is also located in the sftpManager. This time it needs no routing because the createFile()-function already has the connSettings variable and passes it to the transFile()-function (line 22). \\ \\
As the transfer mode is set to binary by default, the .txt file would not be recognized by the JES-Spool if it would be submitted now. To change this, it is necessary to change the transfer mode to \textit{text}. The Co:Z transfer mode can be changed by executing:
\begin{lstlisting}[language=HTML]
sftp>  ls /+mode=text
\end{lstlisting}
\textit{/+mode=text} is a subdirectory. that simply has to be read. Like in the section before, the \textit{readdir}-function is used to read this subdirectory and with this, change the transfer-mode.
Now the file is ready to be transferred to the JES-SPOOL. The command for this action would usually be:\begin{lstlisting}[language=HTML]
put <local file-path> //-JES.INTRDR/MYJOB
\end{lstlisting}
The ssh2 client executes this by placing a readStream (get) to get the file that has just been created and a writeStream (put) to send this file to the JES subdirectory \textit{MYJOB}.
\ \\

\begin{lstlisting}[language=Java]
//sftpManager.js

  transFile(req, res) {
    var changeMod = '/+mode=text'

    var conn = new Client();
      conn.on('ready', function() {
        console.log('Client -> ready');
          conn.sftp(function(err, sftp) {
               if (err) {
                 //send error to myController if something went wrong
                 res.send(400);
               } else {

                 // change Transfer Mode with ls /+mode=text
                 sftp.readdir(changeMod, function(err, list) {
                        if (err) throw err;
                        // List the Change in the console
                        console.log('mode -> text');
                 });

                 var fs = require("fs"); // Use node filesystem

                 //Read the textfile and send it to 
                 //subdirectory, called "myjob"
                 var readStream = 
                 		fs.createReadStream( './Spool-files/' 
										+ req.session.user.user + '/JCL.txt' );
                 var writeStream = 
                 		sftp.createWriteStream( '//-JES.INTRDR/MYJOB' );

                 writeStream.on('close',function () {
                 });

                 writeStream.on('end', function () {
                     console.log( "sftp connection closed" );
                     conn.close();
                 });

                 // initiate transfer of file
                 readStream.pipe( writeStream );
                 //send success to myController
                 res.send(200);
                 console.log( "file transferred succesfully" );
               }
             });
          }).connect(connSettings);
  },
};\end{lstlisting}
\ \\
\newpage
\subsection{Result} \label{result}
After this all has happened \textit{myController.js} gets a response in form of 200=success or 400=error and performs the following tasks.\\
\begin{lstlisting}[language=Java]
//myController.js

function createSpoolfile() {

  [...]
  
  $.ajax({
    type: 'POST',
    url: '/create-file',
    data: json,
    success: function() {
      resultinfo.style.display = "none";
      document.getElementById("goodresult").style.display = 'block';
    },
    error: function() {
      resultinfo.style.display = "none";
      document.getElementById("badresult").style.display = 'block';
    }
  });

\end{lstlisting}

Depending on the job submit was successful or not, predefined div containers are shown instead of the usual resultinfo-div that advise the user to check the connection in case of an error or show him a success message like this one in case he or she succeeded.\\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.37]{img/view_success.png}
	\caption{Success Message}
	\label{successview}
\end{figure}
\ \\
By clicking the button \textit{Go to overview} the page refreshes, what triggers the functions of chapter \ref{yourjobs} again to get a list containing the new job.\\

\section{Learning Effect}\label{learning-content}
Since the application in first place is designed to give students and system operators in general the ability to learn submitting batch-jobs, the functionality itself is not enough. This chapter will describe three techniques to give the user a learning effect. \\
The following functions will take place in a file called \textit{content-functions.js} that is running on the frontend and is written in jQuery. \\
\subsection{Information on MVS Utilities}
Before creating a job, the user shall have the option to know, which effect it will have after submitting. For this the user can choose between the different \ac{MVS} Utilities the mainframe offers and get an overview on what this utility is able to do. \\
In this case, a select-field containing those nine utilities will on change reveal details regarding to this program. The informations on the utilities come from the essential mainframe guide by Mitra Gopaul \cite{gopaul1993ibm}.\\

\begin{lstlisting}[language=HTML]
//index.html

<div class="select-wrapper" style="margin-bottom:20px;">
<select id="mySelect" class="jobhint">
  <option value="" selected disabled hidden>
  	Choose MVS Utility to get some introductions.</option>
  <option name="step1">IEBGENER</option>
  <option name="step2">IEBPTPCH</option>
  <option name="step3">IEBCOPY</option>
  <option name="step4">IEBUPDTE</option>
  <option name="step5">IEBCOMPR</option>
  <option name="step6">IEHPROGM</option>
  <option name="step7">SORT</option>
  <option name="step8">IEWL</option>
  <option name="step9">IGYCRCTL</option>
</select>
</div>
\end{lstlisting}
\ \\
The \textit{index.html} contains a select-field where the user can choose the program he wants to use for his job.\\
If he chooses to the program IEBGENER for example, the select field reveals the information that is written in the div with the ID IEBGENER that is shown below.
\ \\
\begin{lstlisting}[language=HTML]
//index.html

<div id="IEBGENER" class="infobox">
  <h3>IEBGENER</h3>
  <p>This utility has many functions. They are:</p>
  <p><b>1. TRANSFER DATA</b></p>
  <ul style="margin-left:20px;">
    <li>From a sequential dataset to a member of a 
    	partitioned dataset.</li>
    <li>From a member of a partitioned dataset to a 
    	sequential dataset.</li>
    <li>From a tape file to a disk file.</li>
    <li>From a disk file to a tape file.</li>
  </ul>
  <p><b>2. PRINT A FILE.</b> IEBGENER can send the contents of a 
  	sequential or PDS file to a printer.</p>
  <p><b>3. REORGANIZE A FILE.</b> IEBGENER can be used to expand a 
  	partitioned dataset. Also, it can be used to produce an "edited" 
		sequential dataset or PDS member. Some of the 
			editing functions are:</p>
  <ul style="margin-left:20px;">
    <li>Rearrange or omit data fields in a record.</li>
    <li>Replace data with literal values.</li>
    <li>Convert data from packed decimal to unpacked decimal and</li>
    <li>from unpacked decimal to packed decimal</li>
  </ul>
  <p><b>4. CHANGE FILE CHARACTERISTICS.</b> IEBGENER can be 
  	used to "reblock" a file. For example a file with LRECL=80, 
		BLKSIZE=800 can be copied to a file with LRECL=80, BLKSIZE=8000.</p>
</div>
\end{lstlisting}
\ \\
The revealing of this div is accomplished through the following jQuery-function.
\ \\
\begin{lstlisting}[language=Java]
//conent-functions.js

// Change infoboxes on select
$(function() {
      $('#mySelect').change(function(){
          $('.infobox').hide();
          $('.infosteps').hide();
          $("#stepside").addClass('split');
          $('#' + $(':selected',this).attr('name')).show();
          $('#' + $(this).val()).show();
      });
  });
\end{lstlisting}
\ \\
After checking which utility is selected this function first hides infoboxes if there were any selected before. Than it reveals the content of the div-container above.\\ \\
As it can be seen here there are not only the infoboxes that are shown on change but also the additional steps that have to be done to get this job running.\\
As these steps are slightly different for every program they are also changed by selecting another utility. For this the above function uses the attribute \textit{name} and searches for a div with the deposited value as ID.\\
By adding the class \textit{split} to the container containing the textarea, those steps to implement the job are shown directly next to the textarea. Details to the steps become evident by hovering the specific step as you can see on Fig. \ref{jobstep}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.17]{img/view_step.jpg}
	\caption{Reveal job-step by hovering}
	\label{jobstep}
\end{figure}
\ \\
\subsection{Return Codes}
After a job was submitted, a few jobs provide a code that describes the status of the process. The user here again will have the ability to read those return codes by selecting the utility he chose based on the job he submitted before. With this he can find out whether his job was successful or not and if not, what went wrong. This option should give the possibility to make mistakes but learn from them immediately.\\
\begin{lstlisting}[language=HTML]
//index.html

     <div id="codearea">
       <h5>Return Codes</h5>
       <h7>A few utilities provide a return code after you submitted the 
       	job. Their meaning can be looked up here.</h7>
       <select id="codeSelect">
         <option value="" selected disabled hidden>Get the return codes 
         	to a specific utility.</option>
         <option value="code1">IEBGENER</option>
         <option value="code2">IEBPTPCH</option>
         <option value="code3">IEBCOPY</option>
         <option value="code4">IEBUPDTE</option>
         <option value="code5">IEBCOMPR</option>
       </select>
       
       //for example the IEBGENER return codes:
       <div class="codes" id="code1">
          <ul>
           <li><b>00</b> The processing is successfully completed.</li>
           <li><b>04</b> The processing is completed but a 
           	warning message is issued.</li>
           <li><b>08</b> The processing is terminated. 
           	Processing of header labels only is requested.</li>
           <li><b>12</b> The program terminated; 
           	a fatal error occurred.</li>
           <li><b>16</b> The program terminated; 
           	a user routine returned error code 16.</</li>
         </ul>
       </div>
\end{lstlisting}
Similar to the infoboxes, a jQuery function reveals the return codes requested by the user based on the job utility he has chosen. 
\begin{lstlisting}[language=Java]
//content-functions.js

// Change return codes on select
$(function() {
      $('#codeSelect').change(function(){
          $('.codes').hide();
          $('#' + $(this).val()).show();
      });
  });
\end{lstlisting}
The content again originates from \cite{gopaul1993ibm}. The return codes for a IEBGENER for example are shown as followed:
\ \\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{img/view_returncodes.png}
	\caption{Return codes for IEBGENER}
	\label{return}
\end{figure}
\ \\
\subsection{Gamification}
Last but not least the users progress shall be tracked throughout the whole time he or she uses this program. The fact that all the jobs that have been submitted are located in one subdirectory and are shown in this program gives the possibility to count those jobs and based on this classify the training progress into several levels. \\
----- Describe gamification deeper --- with sources ------------\\
To let the user know which level it currently is in or which level it can expect within the next few steps, an area right beneath the job list is implemented. Here a few sentences are written down in combination with an icon to each level to encourage the user to use the program more often and level up.\\
\begin{lstlisting}[language=HTML]
//index.html

 <section>
     <div class="content">
       <div class="inner">
         <h2 id="lvlprogress">Training progress</h2>
         <p id="joblistout">Show me your jobs and I tell you 
         	how good you are.</p>
           <ul class="actions">
           <li><a href="#two" class="button">Create a New Job</a></li>
           </ul>
       </div>
     </div>
     <a id="lvllink" class="image"><img id="lvlicon" 
     	src="assets/css/images/apprentice.svg" alt="Level image data" 
		data-position="center center" /></a>
 </section>
\end{lstlisting}
\ \\
To change this area based on the users progress the following function counts the jobs that are listed in the users' JES-Spool and changes the content of the area above.\\
\ \\
\begin{lstlisting}[language=Java]
// Training progress
$( document ).ready(function() {
  var existCondition = setInterval(function() {
    if ($('#jobtable').length) {
    console.log('ready to count');
    clearInterval(existCondition);

      var i = $('#jobtable >tbody >tr').length;
      var g = $('#joblistout'); //Change text
      var l = $('#lvlprogress'); //Change level
      var p = $('#lvlicon'); //Change icon
      var u = $('#lvllink'); //Change link that contains icon


      if (i == 0) {
      g.text("Oh welcome rookie. You didn't submit any Jobs yet. 
      		Go ahead and learn JCL by submitting your first Job.");
      l.text("Traingslevel: Rookie")
    } else if (i == 1) {
      g.text("Congratiulations you created your first job.");
      l.text("Traingslevel: Rookie")
    } else if (i < 5) {
      var n = 5-i;
      g.text("Wow. You have submitted " + i + " Jobs so far. 
      		Only " + n + " Jobs left to be an apprentice.");
      l.text("Traingslevel: Rookie")
    } else if (i == 5) {
      g.text("Congratiulations. You have submitted " + i + " Jobs. 
      		You are an apprentice now.");
      l.text("Traingslevel: Apprentice")
    } else if (i > 5, i < 10) {
      var n = 10-i;
      g.text("Wow. You have submitted " + i + " Jobs so far. 
      		Only " + n + " Jobs left to be a journeyman.");
      l.text("Traingslevel: Apprentice")
    } else if (i == 10) {
      g.text("Congratiulations. You have submitted " + i + " Jobs. 
      		You can call yourself a journeyman now.");
      l.text("Traingslevel: Journeyman")
      u.attr('style', 'background-image: 
      			url("assets/css/images/journeyman.svg")');
      p.attr("src", "assets/css/images/journeyman.svg");
    } else if (i > 10, i < 20) {
      g.text("You have submitted " + i + " Jobs so far. 
      		Go ahead journeyman. Become a master.");
      l.text("Traingslevel: Journeyman")
      u.attr('style', 'background-image: 
      			url("assets/css/images/journeyman.svg")');
      p.attr("src", "assets/css/images/journeyman.svg");
    } else if (i == 20) {
      g.text("Teach me master. 
      		That is what people will say to you from now.");
      l.text("Traingslevel: Master")
      u.attr('style', 'background-image: 
      			url("assets/css/images/master.svg")');
      p.attr("src", "assets/css/images/master.svg");
    } else if (i > 20, i < 30) {
      var n = 30-i;
      g.text("The Batch is yours, master. 
      		You are on a good way to become a ninja. 
      		For this you need to submit " + n + " more jobs.");
      l.text("Traingslevel: Master")
      u.attr('style', 'background-image: 
      			url("assets/css/images/master.svg")');
      p.attr("src", "assets/css/images/master.svg");
    } else if (i == 30) {
      g.text("Master Splinter would be proud of you. 
      		You are a Batch-ninja now.");
      l.text("Traingslevel: Ninja")
      u.attr('style', 'background-image: 
      			url("assets/css/images/ninja.svg")');
      p.attr("src", "assets/css/images/ninja.svg");
    } else if (i > 30, i < 50) {
      g.text("Once a ninja - always a ninja. Keep submitting. 
      		One day you will be a sensei.");
      l.text("Traingslevel: Ninja")
      u.attr('style', 'background-image: 
      			url("assets/css/images/ninja.svg")');
      p.attr("src", "assets/css/images/ninja.svg");
    } else if (i >= 50) {
      g.text("Konichiwa Sensei.");
      l.text("Traingslevel: Sensei")
      u.attr('style', 'background-image: 
      				url("assets/css/images/sensei.svg")');
      p.attr("src", "assets/css/images/sensei.svg");
    }
   }
  }, 100); // check every 100ms
});
\end{lstlisting}
As this function reveals, it first waits, till the table from chapter \ref{yourjobs} has loaded. For this an interval is set which is looking for the table every 100ms. When the table has loaded it changes the content in the training progress area in index.html based on how many jobs the user submitted so far.\\
The user here can pass six different levels - Rookie, Apprentice, Journeyman, Master, Ninja and Sensei. \\
A user that submitted 9 jobs for example is in the level Apprentice. If he submits one more job he will be a journeyman.\\
\ \\
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.4]{img/view_training.png}
	\caption{Training progress: Level Apprentice}
	\label{training}
\end{figure}
\ \\

\newpage
\section{Proof of Concept}
\section{Evaluation}

\newpage





%\end{onehalfspacing}

\newpage
\bibliographystyle{plain}
\bibliography{bibfile}


\newpage
\section{Appendices}






\end{document}